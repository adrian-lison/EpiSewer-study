estimateR_job <- function(measurements_df, flow_df, load_per_case,
                          generation_dist, incubation_dist, shedding_dist,
                          fit_opts = list(
                            estimateR_seed = 0,
                            estimation_window = 3,
                            minimum_cumul_incidence = 12,
                            n_bootstrap_reps = 50,
                            data_points_incl = 21
                          )) {
  job_args <- as.list(environment())
  
  inputs <- list(
    measurements_df, flow_df, load_per_case,
    generation_dist, incubation_dist, shedding_dist
  )
  
  #data_timestamp <- 
  checksums <- list(
    input = digest::digest(inputs, algo = "md5"),
    model = digest::digest(
      file = here::here("code", "ww_estimateR_functions.R"), algo = "md5"
    ),
    fit_opts = digest::digest(fit_opts, algo = "md5"),
    init = digest::digest("no_inits")
  )  
  
  run <- function() do.call(runEstimateR, job_args)
  
  return(list(args = job_args, run = run, checksums = checksums))
}

runEstimateR <- function(measurements_df, flow_df, load_per_case,
                         generation_dist, incubation_dist, shedding_dist,
                         fit_opts = list(
                           estimateR_seed = 0,
                           estimation_window = 3,
                           minimum_cumul_incidence = 12,
                           n_bootstrap_reps = 50,
                           data_points_incl = 21
                         )) {
  set.seed(fit_opts$estimateR_seed)
  scaled_df <- scale_to_cases(
    measurements_df,
    flow_df,
    load_per_case
  )
  
  scaled_df <- interpolate_measurements(
    scaled_df,
    date_col = "date",
    measurement_cols = c("cases_scaled"),
    log_scale = TRUE
  )
  
  r_estimates <- estimateR::get_block_bootstrapped_estimate(
    scaled_df$cases_scaled,
    N_bootstrap_replicates = fit_opts$n_bootstrap_reps,
    smoothing_method = "LOESS",
    deconvolution_method = "Richardson-Lucy delay distribution",
    estimation_method = "EpiEstim sliding window",
    uncertainty_summary_method = "original estimate - CI from bootstrap estimates",
    minimum_cumul_incidence = fit_opts$minimum_cumul_incidence,
    combine_bootstrap_and_estimation_uncertainties = TRUE,
    delay = list(incubation_dist, shedding_dist),
    estimation_window = fit_opts$estimation_window,
    data_points_incl = fit_opts$data_points_incl,
    ref_date = min(scaled_df$date, na.rm = TRUE),
    method = "non_parametric_si",
    si_distr = c(0, generation_dist),
    time_step = "day",
    output_Re_only = F)
  r_estimates <- scaled_df |> 
    left_join(r_estimates, by = c("date" = "date")) |> 
    tidyr::fill(
      wwtp,
      target,
      .direction = "updown"
    ) |> 
    transmute(
      #wwtp = wwtp
      #target = target,
      date = date,
      #approach = "estimateR",
      #model_checksum = model_checksum,
      #input_checksum = input_checksum,
      #fitopts_checksum = fitopts_checksum,
      #init_checksum = init_checksum,
      #data_timestamp = data_timestamp,
      mean = Re_estimate,
      median = NA,
      lower_outer = pmin(CI_down_Re_estimate, Re_lowHPD, na.rm = T),
      lower_inner = bootstrapped_CI_down_Re_estimate,
      upper_inner = bootstrapped_CI_up_Re_estimate,
      upper_outer = pmax(CI_up_Re_estimate, Re_highHPD, na.rm = T)
    ) |> 
    filter(!is.na(mean))
  
  return(r_estimates)
}

scale_to_cases <- function(measurements_df, flow_df, load_per_case) {
  setDT(measurements_df)
  setDT(flow_df)
  joincols <- c(
    "wwtp",
    "date"
  )
  joined_df <- flow_df[measurements_df, on = joincols]
  if (any(is.na(joined_df[,flow]))) {
    rlang::abort("Missing flow values in modeled time period. Please impute beforehand.")
  }
  joined_df[, cases_scaled := gc_per_mlww * flow / load_per_case]
  return(joined_df)
}

#' Do linear interpolation of measurements generate daily values
#' @param data_frame The input data frame
#' @param date_col The name of the date column
#' @param measurement_cols The list of names of the measurement column(s)
#' @return The dataframe with daily measurements generated by linear interpolation
interpolate_measurements <- function(data_frame, date_col, measurement_cols, log_scale = TRUE) {
  data_frame <- as.data.frame(data_frame)
  data_frame <- arrange(data_frame, date)
  data_frame$date_2 <- as.Date(data_frame[, date_col])
  daily_dates <- data.frame(
    date = seq.Date(
      min(data_frame$date_2),
      max(data_frame$date_2),
      by = "days"
    )
  )
  data_frame_interp <- data_frame %>%
    mutate(is_observation = T) %>%
    full_join(daily_dates, by = setNames(nm = date_col, "date")) %>%  # https://stackoverflow.com/questions/28399065/dplyr-join-on-by-a-b-where-a-and-b-are-variables-containing-strings
    arrange(!!sym(date_col))
  
  if (log_scale) {
    data_frame_interp <- data_frame_interp |> 
      mutate(across(all_of(measurement_cols), ~ log(.x+0.1)))
  }
  
  data_frame_interp <- data_frame_interp |> 
    mutate(across(all_of(measurement_cols), ~ zoo::na.approx(.x, na.rm = F)))
  
  if (log_scale) {
    data_frame_interp <- data_frame_interp |> 
      mutate(across(all_of(measurement_cols), ~ exp(.x)-0.1))
  }
  return(data_frame_interp)
}

#' Do cubic spline interpolation of measurements generate daily values
#' @param data_frame The input data frame
#' @param date_col The name of the date column
#' @param measurement_cols The list of names of the measurement column(s)
#' @return The dataframe with daily measurements generated by cubic spline interpolation
interpolate_measurements_cubic_spline <- function(data_frame, date_col, measurement_cols) {
  data_frame <- as.data.frame(data_frame)
  data_frame$date_2 <- as.Date(data_frame[, date_col])
  daily_dates <- data.frame(
    date = seq.Date(
      min(data_frame$date_2),
      max(data_frame$date_2),
      by = "days"
    )
  )
  data_frame_all_dates <- data_frame %>%
    mutate(is_observation = T) %>%
    full_join(daily_dates, by = setNames(nm = date_col, "date")) %>%  # https://stackoverflow.com/questions/28399065/dplyr-join-on-by-a-b-where-a-and-b-are-variables-containing-strings
    arrange(!!sym(date_col)) %>%
    mutate(x = 1:n())
  data_frame_all_dates_obs_only <- data_frame_all_dates %>% filter(is_observation)
  
  for (colname in measurement_cols) {
    interpolated_values <- pracma::cubicspline(
      x = data_frame_all_dates_obs_only$x,
      y = data_frame_all_dates_obs_only[[colname]],
      xi = data_frame_all_dates$x)
    data_frame_all_dates[[colname]] <- case_when(interpolated_values < 0 ~ 0, T ~ interpolated_values)
  }
  
  return(data_frame_all_dates %>% dplyr::select(-x))
}

sim_conv <- function(a, b) {
  c <- rep(0, 1 + (length(a) - 1) + (length(b) - 1))
  for (t in 0:(length(c)-1)) {
    for (t1 in 0:t) {
      t2 <- t - t1
      c[t+1] <-  c[t+1] + ifelse(t1+1>length(a),0,a[t1+1]) * ifelse(t2+1>length(b),0,b[t2+1])
    }
  }
  return(c)
}
